package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"time"

	"github.com/shirloin/backend/graph/model"
	"github.com/shirloin/backend/service"
	"gorm.io/gorm"
)

// GetLimitPosts is the resolver for the getLimitPosts field.
func (r *queryResolver) GetLimitPosts(ctx context.Context, limit int, after *string) (*model.PostConnection, error) {
	user := ctx.Value("TokenValue").(*model.User)
	var posts []*model.Post
	var result model.PostConnection

	query := r.DB.Preload("Comment").Preload("File").Preload("Group").Order("created_at DESC")

	if after != nil {
		afterTime, err := time.Parse(time.RFC3339, *after)
		if err != nil {
			return nil, err
		}
		query = query.Where("created_at < ?", afterTime)
	}

	if err := query.Limit(limit).Find(&posts).Error; err != nil {
		return nil, err
	}
	var filteredPosts []*model.Post
	for _, post := range posts {
		if post.UserID == user.ID {
			filteredPosts = append(filteredPosts, post)
		} else if post.Privacy == "Public" {
			filteredPosts = append(filteredPosts, post)
		} else if post.Privacy == "Private" && service.IsAlreadyFriend(post.UserID, user.ID) {
			filteredPosts = append(filteredPosts, post)
		}
	}

	if len(filteredPosts) == 0 {
		return nil, nil
	}

	edges := make([]*model.PostEdge, len(filteredPosts))
	for i, post := range filteredPosts {
		cursor := post.CreatedAt.Format(time.RFC3339)
		edges[i] = &model.PostEdge{
			Cursor: cursor,
			Node:   post,
		}
	}
	var hasNextPage bool
	var nextPost model.Post
	if err := query.Offset(limit).First(&nextPost).Error; err != nil {
		if !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}
	} else {
		hasNextPage = true
	}

	result = model.PostConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			EndCursor:   &edges[len(edges)-1].Cursor,
			HasNextPage: hasNextPage,
		},
	}
	return &result, nil
}

// GetLimitUsers is the resolver for the getLimitUsers field.
func (r *queryResolver) GetLimitUsers(ctx context.Context, limit int, after *string) (*model.UserConnection, error) {
	var users []*model.User
	var result model.UserConnection

	query := r.DB.Order("id DESC")

	if after != nil {
		query = query.Where("id < ?", after)
	}

	if err := query.Limit(limit).Find(&users).Error; err != nil {
		return nil, err
	}

	edges := make([]*model.UserEdge, len(users))
	for i, post := range users {
		cursor := post.ID
		edges[i] = &model.UserEdge{
			Cursor: cursor,
			Node:   post,
		}
	}
	var hasNextPage bool
	var nextPost model.Post
	if err := query.Offset(limit).First(&nextPost).Error; err == nil {
		hasNextPage = true
	}

	result = model.UserConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			EndCursor:   &edges[len(edges)-1].Cursor,
			HasNextPage: hasNextPage,
		},
	}
	return &result, nil
}
