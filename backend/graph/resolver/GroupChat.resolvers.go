package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/shirloin/backend/graph"
	"github.com/shirloin/backend/graph/model"
)

// Room is the resolver for the room field.
func (r *groupChatResolver) Room(ctx context.Context, obj *model.GroupChat) (*model.GroupRoom, error) {
	var room *model.GroupRoom
	return room, r.DB.First(&room, "id = ?", obj.GroupRoomID).Error
}

// User is the resolver for the user field.
func (r *groupChatResolver) User(ctx context.Context, obj *model.GroupChat) (*model.User, error) {
	var user *model.User
	return user, r.DB.First(&user, "id = ?", obj.UserID).Error
}

// CreateGroupChat is the resolver for the createGroupChat field.
func (r *mutationResolver) CreateGroupChat(ctx context.Context, inputGroupChat model.NewGroupChat) (*model.GroupChat, error) {
	chat := &model.GroupChat{
		ID:          uuid.NewString(),
		GroupRoomID: inputGroupChat.GroupRoomID,
		UserID:      inputGroupChat.UserID,
		Message:     inputGroupChat.Message,
		Type:        "",
		CreatedAt:   time.Now(),
	}
	if err := r.DB.Save(&chat).Error; err != nil {
		return nil, err
	}
	var chats []*model.GroupChat
	if err := r.DB.Find(&chats, "group_room_id = ?", inputGroupChat.GroupRoomID).Error; err != nil {
		close(r.chatChannel[inputGroupChat.GroupRoomID][inputGroupChat.UserID])
	}
	for _, ch := range r.chatChannel[inputGroupChat.GroupRoomID] {
		ch <- chats
	}
	return chat, nil
}

// GetGroupChat is the resolver for the getGroupChat field.
func (r *queryResolver) GetGroupChat(ctx context.Context, groupRoomID string) ([]*model.GroupChat, error) {
	var chat []*model.GroupChat
	return chat, r.DB.Find(&chat, "group_room_id = ?", groupRoomID).Error
}

// GetGroupChatUsers is the resolver for the getGroupChatUsers field.
func (r *queryResolver) GetGroupChatUsers(ctx context.Context, groupRoomID string) ([]*model.User, error) {
	var users []*model.User
	return users, r.DB.Find(&users, "group_room_id = ?", groupRoomID).Error
}

// GroupChatCreated is the resolver for the groupChatCreated field.
func (r *subscriptionResolver) GroupChatCreated(ctx context.Context, userID string, groupRoomID string) (<-chan []*model.GroupChat, error) {
	if r.chatChannel == nil {
		r.chatChannel = make(map[string]map[string]chan []*model.GroupChat)
	}
	if r.chatChannel[groupRoomID] == nil {
		r.chatChannel[groupRoomID] = make(map[string]chan []*model.GroupChat)
	}
	if r.chatChannel[groupRoomID][userID] == nil {
		r.chatChannel[groupRoomID][userID] = make(chan []*model.GroupChat)
	}

	var chats []*model.GroupChat
	if err := r.DB.Find(&chats, "group_room_id = ?", groupRoomID).Error; err != nil {
		close(r.chatChannel[groupRoomID][userID])
	}
	go func() {
		r.chatChannel[groupRoomID][userID] <- chats
		for {
			select {
			case <-ctx.Done():
				fmt.Println("Close")
				delete(r.chatChannel[groupRoomID], userID)
				return
			}
		}
	}()

	return r.chatChannel[groupRoomID][userID], nil
}

// GroupChat returns graph.GroupChatResolver implementation.
func (r *Resolver) GroupChat() graph.GroupChatResolver { return &groupChatResolver{r} }

type groupChatResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *groupChatResolver) GroupRoom(ctx context.Context, obj *model.GroupChat) (*model.GroupRoom, error) {
	var room *model.GroupRoom
	return room, r.DB.First(&room, "id = ?", obj.GroupRoomID).Error
}
